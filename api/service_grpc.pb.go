// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: api/service.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthenticationService_SignUp_FullMethodName         = "/userAPI.AuthenticationService/SignUp"
	AuthenticationService_Login_FullMethodName          = "/userAPI.AuthenticationService/Login"
	AuthenticationService_RefreshToken_FullMethodName   = "/userAPI.AuthenticationService/RefreshToken"
	AuthenticationService_ValidateToken_FullMethodName  = "/userAPI.AuthenticationService/ValidateToken"
	AuthenticationService_ForgotPassword_FullMethodName = "/userAPI.AuthenticationService/ForgotPassword"
)

// AuthenticationServiceClient is the client API for AuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthenticationServiceClient interface {
	SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error)
}

type authenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticationServiceClient(cc grpc.ClientConnInterface) AuthenticationServiceClient {
	return &authenticationServiceClient{cc}
}

func (c *authenticationServiceClient) SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignUpResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_SignUp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForgotPasswordResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_ForgotPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticationServiceServer is the server API for AuthenticationService service.
// All implementations must embed UnimplementedAuthenticationServiceServer
// for forward compatibility.
type AuthenticationServiceServer interface {
	SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error)
	mustEmbedUnimplementedAuthenticationServiceServer()
}

// UnimplementedAuthenticationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthenticationServiceServer struct{}

func (UnimplementedAuthenticationServiceServer) SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUp not implemented")
}
func (UnimplementedAuthenticationServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthenticationServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgotPassword not implemented")
}
func (UnimplementedAuthenticationServiceServer) mustEmbedUnimplementedAuthenticationServiceServer() {}
func (UnimplementedAuthenticationServiceServer) testEmbeddedByValue()                               {}

// UnsafeAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticationServiceServer will
// result in compilation errors.
type UnsafeAuthenticationServiceServer interface {
	mustEmbedUnimplementedAuthenticationServiceServer()
}

func RegisterAuthenticationServiceServer(s grpc.ServiceRegistrar, srv AuthenticationServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthenticationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthenticationService_ServiceDesc, srv)
}

func _AuthenticationService_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).SignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_SignUp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).SignUp(ctx, req.(*SignUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_ForgotPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgotPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).ForgotPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_ForgotPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).ForgotPassword(ctx, req.(*ForgotPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthenticationService_ServiceDesc is the grpc.ServiceDesc for AuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "userAPI.AuthenticationService",
	HandlerType: (*AuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignUp",
			Handler:    _AuthenticationService_SignUp_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AuthenticationService_Login_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthenticationService_RefreshToken_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _AuthenticationService_ValidateToken_Handler,
		},
		{
			MethodName: "ForgotPassword",
			Handler:    _AuthenticationService_ForgotPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/service.proto",
}

const (
	ClassManagerService_CreateClass_FullMethodName = "/userAPI.ClassManagerService/CreateClass"
	ClassManagerService_GetClasses_FullMethodName  = "/userAPI.ClassManagerService/GetClasses"
	ClassManagerService_UpdateClass_FullMethodName = "/userAPI.ClassManagerService/UpdateClass"
	ClassManagerService_DeleteClass_FullMethodName = "/userAPI.ClassManagerService/DeleteClass"
)

// ClassManagerServiceClient is the client API for ClassManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClassManagerServiceClient interface {
	CreateClass(ctx context.Context, in *CreateClassRequest, opts ...grpc.CallOption) (*CreateClassResponse, error)
	GetClasses(ctx context.Context, in *GetClassesRequest, opts ...grpc.CallOption) (*GetClassesResponse, error)
	UpdateClass(ctx context.Context, in *UpdateClassRequest, opts ...grpc.CallOption) (*UpdateClassResponse, error)
	DeleteClass(ctx context.Context, in *DeleteClassRequest, opts ...grpc.CallOption) (*DeleteClassResponse, error)
}

type classManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClassManagerServiceClient(cc grpc.ClientConnInterface) ClassManagerServiceClient {
	return &classManagerServiceClient{cc}
}

func (c *classManagerServiceClient) CreateClass(ctx context.Context, in *CreateClassRequest, opts ...grpc.CallOption) (*CreateClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClassResponse)
	err := c.cc.Invoke(ctx, ClassManagerService_CreateClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classManagerServiceClient) GetClasses(ctx context.Context, in *GetClassesRequest, opts ...grpc.CallOption) (*GetClassesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClassesResponse)
	err := c.cc.Invoke(ctx, ClassManagerService_GetClasses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classManagerServiceClient) UpdateClass(ctx context.Context, in *UpdateClassRequest, opts ...grpc.CallOption) (*UpdateClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateClassResponse)
	err := c.cc.Invoke(ctx, ClassManagerService_UpdateClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classManagerServiceClient) DeleteClass(ctx context.Context, in *DeleteClassRequest, opts ...grpc.CallOption) (*DeleteClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClassResponse)
	err := c.cc.Invoke(ctx, ClassManagerService_DeleteClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClassManagerServiceServer is the server API for ClassManagerService service.
// All implementations must embed UnimplementedClassManagerServiceServer
// for forward compatibility.
type ClassManagerServiceServer interface {
	CreateClass(context.Context, *CreateClassRequest) (*CreateClassResponse, error)
	GetClasses(context.Context, *GetClassesRequest) (*GetClassesResponse, error)
	UpdateClass(context.Context, *UpdateClassRequest) (*UpdateClassResponse, error)
	DeleteClass(context.Context, *DeleteClassRequest) (*DeleteClassResponse, error)
	mustEmbedUnimplementedClassManagerServiceServer()
}

// UnimplementedClassManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClassManagerServiceServer struct{}

func (UnimplementedClassManagerServiceServer) CreateClass(context.Context, *CreateClassRequest) (*CreateClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClass not implemented")
}
func (UnimplementedClassManagerServiceServer) GetClasses(context.Context, *GetClassesRequest) (*GetClassesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClasses not implemented")
}
func (UnimplementedClassManagerServiceServer) UpdateClass(context.Context, *UpdateClassRequest) (*UpdateClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClass not implemented")
}
func (UnimplementedClassManagerServiceServer) DeleteClass(context.Context, *DeleteClassRequest) (*DeleteClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClass not implemented")
}
func (UnimplementedClassManagerServiceServer) mustEmbedUnimplementedClassManagerServiceServer() {}
func (UnimplementedClassManagerServiceServer) testEmbeddedByValue()                             {}

// UnsafeClassManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClassManagerServiceServer will
// result in compilation errors.
type UnsafeClassManagerServiceServer interface {
	mustEmbedUnimplementedClassManagerServiceServer()
}

func RegisterClassManagerServiceServer(s grpc.ServiceRegistrar, srv ClassManagerServiceServer) {
	// If the following call pancis, it indicates UnimplementedClassManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClassManagerService_ServiceDesc, srv)
}

func _ClassManagerService_CreateClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassManagerServiceServer).CreateClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassManagerService_CreateClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassManagerServiceServer).CreateClass(ctx, req.(*CreateClassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClassManagerService_GetClasses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClassesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassManagerServiceServer).GetClasses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassManagerService_GetClasses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassManagerServiceServer).GetClasses(ctx, req.(*GetClassesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClassManagerService_UpdateClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassManagerServiceServer).UpdateClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassManagerService_UpdateClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassManagerServiceServer).UpdateClass(ctx, req.(*UpdateClassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClassManagerService_DeleteClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassManagerServiceServer).DeleteClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassManagerService_DeleteClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassManagerServiceServer).DeleteClass(ctx, req.(*DeleteClassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClassManagerService_ServiceDesc is the grpc.ServiceDesc for ClassManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClassManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "userAPI.ClassManagerService",
	HandlerType: (*ClassManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClass",
			Handler:    _ClassManagerService_CreateClass_Handler,
		},
		{
			MethodName: "GetClasses",
			Handler:    _ClassManagerService_GetClasses_Handler,
		},
		{
			MethodName: "UpdateClass",
			Handler:    _ClassManagerService_UpdateClass_Handler,
		},
		{
			MethodName: "DeleteClass",
			Handler:    _ClassManagerService_DeleteClass_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/service.proto",
}

const (
	CourseManagerService_GetCourses_FullMethodName = "/userAPI.CourseManagerService/GetCourses"
)

// CourseManagerServiceClient is the client API for CourseManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CourseManagerServiceClient interface {
	GetCourses(ctx context.Context, in *GetCoursesRequest, opts ...grpc.CallOption) (*GetCoursesResponse, error)
}

type courseManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCourseManagerServiceClient(cc grpc.ClientConnInterface) CourseManagerServiceClient {
	return &courseManagerServiceClient{cc}
}

func (c *courseManagerServiceClient) GetCourses(ctx context.Context, in *GetCoursesRequest, opts ...grpc.CallOption) (*GetCoursesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCoursesResponse)
	err := c.cc.Invoke(ctx, CourseManagerService_GetCourses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CourseManagerServiceServer is the server API for CourseManagerService service.
// All implementations must embed UnimplementedCourseManagerServiceServer
// for forward compatibility.
type CourseManagerServiceServer interface {
	GetCourses(context.Context, *GetCoursesRequest) (*GetCoursesResponse, error)
	mustEmbedUnimplementedCourseManagerServiceServer()
}

// UnimplementedCourseManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCourseManagerServiceServer struct{}

func (UnimplementedCourseManagerServiceServer) GetCourses(context.Context, *GetCoursesRequest) (*GetCoursesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCourses not implemented")
}
func (UnimplementedCourseManagerServiceServer) mustEmbedUnimplementedCourseManagerServiceServer() {}
func (UnimplementedCourseManagerServiceServer) testEmbeddedByValue()                              {}

// UnsafeCourseManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CourseManagerServiceServer will
// result in compilation errors.
type UnsafeCourseManagerServiceServer interface {
	mustEmbedUnimplementedCourseManagerServiceServer()
}

func RegisterCourseManagerServiceServer(s grpc.ServiceRegistrar, srv CourseManagerServiceServer) {
	// If the following call pancis, it indicates UnimplementedCourseManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CourseManagerService_ServiceDesc, srv)
}

func _CourseManagerService_GetCourses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCoursesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CourseManagerServiceServer).GetCourses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CourseManagerService_GetCourses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CourseManagerServiceServer).GetCourses(ctx, req.(*GetCoursesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CourseManagerService_ServiceDesc is the grpc.ServiceDesc for CourseManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CourseManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "userAPI.CourseManagerService",
	HandlerType: (*CourseManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCourses",
			Handler:    _CourseManagerService_GetCourses_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/service.proto",
}

const (
	SessionManagerService_StartSession_FullMethodName = "/userAPI.SessionManagerService/StartSession"
	SessionManagerService_EndSession_FullMethodName   = "/userAPI.SessionManagerService/EndSession"
	SessionManagerService_JoinSession_FullMethodName  = "/userAPI.SessionManagerService/JoinSession"
)

// SessionManagerServiceClient is the client API for SessionManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionManagerServiceClient interface {
	StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error)
	EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error)
	JoinSession(ctx context.Context, in *JoinSessionRequest, opts ...grpc.CallOption) (*JoinSessionResponse, error)
}

type sessionManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionManagerServiceClient(cc grpc.ClientConnInterface) SessionManagerServiceClient {
	return &sessionManagerServiceClient{cc}
}

func (c *sessionManagerServiceClient) StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartSessionResponse)
	err := c.cc.Invoke(ctx, SessionManagerService_StartSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerServiceClient) EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndSessionResponse)
	err := c.cc.Invoke(ctx, SessionManagerService_EndSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerServiceClient) JoinSession(ctx context.Context, in *JoinSessionRequest, opts ...grpc.CallOption) (*JoinSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinSessionResponse)
	err := c.cc.Invoke(ctx, SessionManagerService_JoinSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionManagerServiceServer is the server API for SessionManagerService service.
// All implementations must embed UnimplementedSessionManagerServiceServer
// for forward compatibility.
type SessionManagerServiceServer interface {
	StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error)
	EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error)
	JoinSession(context.Context, *JoinSessionRequest) (*JoinSessionResponse, error)
	mustEmbedUnimplementedSessionManagerServiceServer()
}

// UnimplementedSessionManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionManagerServiceServer struct{}

func (UnimplementedSessionManagerServiceServer) StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSession not implemented")
}
func (UnimplementedSessionManagerServiceServer) EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndSession not implemented")
}
func (UnimplementedSessionManagerServiceServer) JoinSession(context.Context, *JoinSessionRequest) (*JoinSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinSession not implemented")
}
func (UnimplementedSessionManagerServiceServer) mustEmbedUnimplementedSessionManagerServiceServer() {}
func (UnimplementedSessionManagerServiceServer) testEmbeddedByValue()                               {}

// UnsafeSessionManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionManagerServiceServer will
// result in compilation errors.
type UnsafeSessionManagerServiceServer interface {
	mustEmbedUnimplementedSessionManagerServiceServer()
}

func RegisterSessionManagerServiceServer(s grpc.ServiceRegistrar, srv SessionManagerServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionManagerService_ServiceDesc, srv)
}

func _SessionManagerService_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServiceServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagerService_StartSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServiceServer).StartSession(ctx, req.(*StartSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManagerService_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServiceServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagerService_EndSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServiceServer).EndSession(ctx, req.(*EndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManagerService_JoinSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServiceServer).JoinSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagerService_JoinSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServiceServer).JoinSession(ctx, req.(*JoinSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionManagerService_ServiceDesc is the grpc.ServiceDesc for SessionManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "userAPI.SessionManagerService",
	HandlerType: (*SessionManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _SessionManagerService_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _SessionManagerService_EndSession_Handler,
		},
		{
			MethodName: "JoinSession",
			Handler:    _SessionManagerService_JoinSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/service.proto",
}

const (
	NotificationManagerService_GetNotifications_FullMethodName = "/userAPI.NotificationManagerService/GetNotifications"
)

// NotificationManagerServiceClient is the client API for NotificationManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationManagerServiceClient interface {
	GetNotifications(ctx context.Context, in *GetNotificationsRequest, opts ...grpc.CallOption) (*GetNotificationsResponse, error)
}

type notificationManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationManagerServiceClient(cc grpc.ClientConnInterface) NotificationManagerServiceClient {
	return &notificationManagerServiceClient{cc}
}

func (c *notificationManagerServiceClient) GetNotifications(ctx context.Context, in *GetNotificationsRequest, opts ...grpc.CallOption) (*GetNotificationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNotificationsResponse)
	err := c.cc.Invoke(ctx, NotificationManagerService_GetNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationManagerServiceServer is the server API for NotificationManagerService service.
// All implementations must embed UnimplementedNotificationManagerServiceServer
// for forward compatibility.
type NotificationManagerServiceServer interface {
	GetNotifications(context.Context, *GetNotificationsRequest) (*GetNotificationsResponse, error)
	mustEmbedUnimplementedNotificationManagerServiceServer()
}

// UnimplementedNotificationManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationManagerServiceServer struct{}

func (UnimplementedNotificationManagerServiceServer) GetNotifications(context.Context, *GetNotificationsRequest) (*GetNotificationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotifications not implemented")
}
func (UnimplementedNotificationManagerServiceServer) mustEmbedUnimplementedNotificationManagerServiceServer() {
}
func (UnimplementedNotificationManagerServiceServer) testEmbeddedByValue() {}

// UnsafeNotificationManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationManagerServiceServer will
// result in compilation errors.
type UnsafeNotificationManagerServiceServer interface {
	mustEmbedUnimplementedNotificationManagerServiceServer()
}

func RegisterNotificationManagerServiceServer(s grpc.ServiceRegistrar, srv NotificationManagerServiceServer) {
	// If the following call pancis, it indicates UnimplementedNotificationManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotificationManagerService_ServiceDesc, srv)
}

func _NotificationManagerService_GetNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationManagerServiceServer).GetNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationManagerService_GetNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationManagerServiceServer).GetNotifications(ctx, req.(*GetNotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationManagerService_ServiceDesc is the grpc.ServiceDesc for NotificationManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "userAPI.NotificationManagerService",
	HandlerType: (*NotificationManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNotifications",
			Handler:    _NotificationManagerService_GetNotifications_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/service.proto",
}
